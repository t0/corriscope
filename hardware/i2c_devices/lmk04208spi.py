#!/usr/bin/python

""" Interface to the LMK04208 PLL via the SC18IS202 II2-to-SPI bridge.

.. History:
    2013-08-08 : JFC : Created
    2014-02-23 JFC: Added register table, select(), masked write.
    2014-03-04 JM: Added default I/O pin configuration at init()
    2014-03-18 JM: Fixed read function to allow reading by register name, not only by register address
                Fixed masking in write function
"""

import time
import os

from .TICSPRO_loader import load_pll_regs


class lmk04208spi(object):
    """
    Implements the interface to the LMK04208 PLL via the SC18IS202 II2-to-SPI bridge.
    """

    # Configuration
    # regs = [
    #     (0,1441856),
    #     (0, 1323520),
    #     (1, 1323521),
    #     (2, 1311522),
    #     (3, 3222536227),
    #     (4, 1075052580),
    #     (5, 2148802053),
    #     (6, 17825798),
    #     (7, 17825799),
    #     (8, 100728840),
    #     (9, 1431655753),
    #     (10, 2432844042),
    #     (11, 67178507),
    #     (12, 453771372),
    #     (13, 587368557),
    #     (14, 33554446),
    #     (15, 2147516431),
    #     (16, 3243574288),
    #     (24, 88),
    #     (25, 46777369),
    #     (26, 2410151962),
    #     (27, 268443163),
    #     (28, 2170908),
    #     (29, 25166653),
    #     (30, 33555262),
    #     (31, 4128799),
    #     ]

    # Configuration
    #  CLKin0: 12.8 MHz
    #  PLL1 Rdiv=120, Nmul=1152, VCO=122.88
    #  PLL2 Rdiv=128, Nmult prescaler=5, Nmult=625, VCO = 3000 MHz
    #  Out0: Div=300, Out=10 MHz
    #  Out1: Div=300, Out=10 MHz
    #  Out2: Div=15,  Out=200 MHz
    #  Out3: Mux=VCO, Div=300, Out=10 MHz
    #  Out4: Mux=Oscin, Div=1, Out=122.88 MHz
    #  Out5: Div=300, Out=10 MHz
    regs = [
        (0 , 0x00160040),
        (0 , 0x00142580),
        (1 , 0x00142581),
        (2 , 0x001401E2),
        # (3 , 0x00142583),
        (3 , 0x80142583), # clkout3 disable
        # (4 , 0x40140024),  # Src=Oscion, div=1, Clkout4=122.88
        (4 , 0x001401E4),  # CSrc=VCO, div=15, clkout4=200 MHz
        (5 , 0x00142585),
        (6 , 0x01100006),
        (7 , 0x01100007),
        (8 , 0x06010008),
        (9 , 0x55555549),
        (10, 0x9102410A),
        (11, 0x0401100B),
        (12, 0x1B0C006C),
        (13, 0x2302886D),
        (14, 0x0200000E),
        (15, 0x8000800F),
        (16, 0xC1550410),
        (24, 0x00000058),
        (25, 0x02C9C419),
        (26, 0x8FA8001A),
        (27, 0x10001E1B),
        (28, 0x0801201C),
        (29, 0x01804E3D),
        (30, 0x05004E3E),
        (31, 0x003F001F),

        ]

    def __init__(self, i2c_interface, address, spi_port=0, port='GPIO', verbose=0):
        """
        """
        self.i2c = i2c_interface
        self.address = address
        self.bus_name = port
        self.spi_port = spi_port

    def init(self, filename="lmk04208_registers.tcs"):
        """
        Load the register values in the .tcs file generated by TICSPRO software.
        """
        regs = load_pll_regs(filename)

        for (reg, value) in regs:
            print(f'Writing Reg {reg} with 0x{value:08X}')
            self.write_word(value)
            time.sleep(0.05)

    def select(self):
        """
        Selects the proper I2C port to talk to this device.
        """
        self.i2c.select_bus(self.bus_name)

    def write(self, data):
        spi_data = bytes([1<<self.spi_port]) + data
        self.select()
        self.i2c.write_read(self.address, spi_data)

    def write_word(self, value):
            self.write(value.to_bytes(4, 'big'))

    # def write_reg(self, register, value, mask=0xff, select=True):
    #     """
    #     Writes a byte to the specified register of the IO Expander.
    #     'register' can be the register address or the register name taken from REGISTER_TABLE.
    #     The I2C port for this device is set prior to the operation if 'select' is True.
    #     If 'mask' is specified, only the bits position that are set in 'mask' are changed.
    #     """
    #     # Convert port name a port address if the name is in the table.
    #     # Otherwise use the argument as a port address directly.
    #     if register in self.REGISTER_TABLE:
    #         register = self.REGISTER_TABLE[register]

    #     if select:
    #         self.select()

    #     if (mask & 0xFF) != 0xff:
    #         old_value = self.i2c.write_read(self.address, data=[register], read_length=1)[0]
    #         new_value = (old_value & (~ mask)) | (value & mask)
    #         # print(f'Pca9575 register={register} old_value={old_value}')
    #     else:
    #         new_value = value

    #     self.i2c.write_read(self.address, data=[register, new_value])

    # def read_reg(self, register, select=True):
    #     """
    #     Read a value to the specified register
    #     """
    #     # Convert port name a port address if the name is in the table.
    #     # Otherwise use the argument as a port address directly.
    #     if register in self.REGISTER_TABLE:
    #         register = self.REGISTER_TABLE[register]

    #     if select:
    #         self.select()

    #     return self.i2c.write_read(self.address, data=[register], read_length=1)[0]

    # def write(self, byte, value, mask=0xff, select=True):
    #     self.write_reg('OUT%i' % byte, value, mask=mask, select=select)

    # def read(self, byte, select=True):
    #     return self.read_reg('IN%i' % byte, select=select)
